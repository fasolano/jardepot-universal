"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.KmlLayerManager = void 0;

var _core = require("@angular/core");

var _rxjs = require("rxjs");

var _googleMapsApiWrapper = require("./../google-maps-api-wrapper");

function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

var __decorate = void 0 && (void 0).__decorate || function (decorators, target, key, desc) {
  var c = arguments.length,
      r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
      d;
  if ((typeof Reflect === "undefined" ? "undefined" : _typeof(Reflect)) === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) {
    if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  }
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};

var __metadata = void 0 && (void 0).__metadata || function (k, v) {
  if ((typeof Reflect === "undefined" ? "undefined" : _typeof(Reflect)) === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};

/**
 * Manages all KML Layers for a Google Map instance.
 */
var KmlLayerManager =
/** @class */
function () {
  function KmlLayerManager(_wrapper, _zone) {
    this._wrapper = _wrapper;
    this._zone = _zone;
    this._layers = new Map();
  }
  /**
   * Adds a new KML Layer to the map.
   */


  KmlLayerManager.prototype.addKmlLayer = function (layer) {
    var newLayer = this._wrapper.getNativeMap().then(function (m) {
      return new google.maps.KmlLayer({
        clickable: layer.clickable,
        map: m,
        preserveViewport: layer.preserveViewport,
        screenOverlays: layer.screenOverlays,
        suppressInfoWindows: layer.suppressInfoWindows,
        url: layer.url,
        zIndex: layer.zIndex
      });
    });

    this._layers.set(layer, newLayer);
  };

  KmlLayerManager.prototype.setOptions = function (layer, options) {
    this._layers.get(layer).then(function (l) {
      return l.setOptions(options);
    });
  };

  KmlLayerManager.prototype.deleteKmlLayer = function (layer) {
    var _this = this;

    this._layers.get(layer).then(function (l) {
      l.setMap(null);

      _this._layers.delete(layer);
    });
  };
  /**
   * Creates a Google Maps event listener for the given KmlLayer as an Observable
   */


  KmlLayerManager.prototype.createEventObservable = function (eventName, layer) {
    var _this = this;

    return new _rxjs.Observable(function (observer) {
      _this._layers.get(layer).then(function (m) {
        m.addListener(eventName, function (e) {
          return _this._zone.run(function () {
            return observer.next(e);
          });
        });
      });
    });
  };

  KmlLayerManager = __decorate([(0, _core.Injectable)(), __metadata("design:paramtypes", [_googleMapsApiWrapper.GoogleMapsAPIWrapper, _core.NgZone])], KmlLayerManager);
  return KmlLayerManager;
}();

exports.KmlLayerManager = KmlLayerManager;