"use strict";

var _core = require("@angular/core");

var _testing = require("@angular/core/testing");

var _polygon = require("../../directives/polygon");

var _googleMapsApiWrapper = require("../google-maps-api-wrapper");

var _polygonManager = require("./polygon-manager");

var _mvcarrayUtils = require("../../utils/mvcarray-utils");

var __assign = void 0 && (void 0).__assign || function () {
  __assign = Object.assign || function (t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
      s = arguments[i];

      for (var p in s) {
        if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
      }
    }

    return t;
  };

  return __assign.apply(this, arguments);
};

describe('PolygonManager', function () {
  beforeEach(function () {
    _testing.TestBed.configureTestingModule({
      providers: [{
        provide: _core.NgZone,
        useFactory: function useFactory() {
          return new _core.NgZone({
            enableLongStackTrace: true
          });
        }
      }, _polygonManager.PolygonManager, _polygon.AgmPolygon, {
        provide: _googleMapsApiWrapper.GoogleMapsAPIWrapper,
        useValue: {
          createPolygon: jest.fn()
        }
      }]
    });
  });
  describe('Create a new polygon', function () {
    it('should call the mapsApiWrapper when creating a new polygon', (0, _testing.inject)([_polygonManager.PolygonManager, _googleMapsApiWrapper.GoogleMapsAPIWrapper], function (polygonManager, apiWrapper) {
      var newPolygon = new _polygon.AgmPolygon(polygonManager);
      polygonManager.addPolygon(newPolygon);
      expect(apiWrapper.createPolygon).toHaveBeenCalledWith({
        clickable: true,
        draggable: false,
        editable: false,
        fillColor: undefined,
        fillOpacity: undefined,
        geodesic: false,
        paths: [],
        strokeColor: undefined,
        strokeOpacity: undefined,
        strokeWeight: undefined,
        visible: undefined,
        zIndex: undefined
      });
    }));
  });
  describe('Delete a polygon', function () {
    it('should set the map to null when deleting a existing polygon', (0, _testing.inject)([_polygonManager.PolygonManager, _googleMapsApiWrapper.GoogleMapsAPIWrapper], function (polygonManager, apiWrapper) {
      var newPolygon = new _polygon.AgmPolygon(polygonManager);
      var polygonInstance = {
        setMap: jest.fn()
      };
      apiWrapper.createPolygon.mockReturnValue(Promise.resolve(polygonInstance));
      polygonManager.addPolygon(newPolygon);
      polygonManager.deletePolygon(newPolygon).then(function () {
        expect(polygonInstance.setMap).toHaveBeenCalledWith(null);
      });
    }));
  });
  describe('Path changes', function () {
    var newPolygon;
    var paths;
    var initLatLng = {
      lat: function lat() {
        return 15;
      },
      lng: function lng() {
        return 15;
      },
      toJSON: function toJSON() {
        return {
          lat: 15,
          lng: 15
        };
      }
    };
    beforeEach((0, _testing.inject)([_polygonManager.PolygonManager, _googleMapsApiWrapper.GoogleMapsAPIWrapper], function (polygonManager, apiWrapper) {
      paths = new _mvcarrayUtils.MvcArrayMock();
      var path = new _mvcarrayUtils.MvcArrayMock();
      path.push(initLatLng);
      paths.push(path);
      var polygonInstance = {
        getPaths: function getPaths() {
          return paths;
        },
        setMap: jest.fn()
      };
      apiWrapper.createPolygon.mockReturnValue(Promise.resolve(polygonInstance));
      newPolygon = new _polygon.AgmPolygon(polygonManager);
      polygonManager.addPolygon(newPolygon);
    }));
    afterEach(function (done) {
      (0, _testing.inject)([_polygonManager.PolygonManager], function (polygonManager) {
        polygonManager.deletePolygon(newPolygon).then(done);
      })();
    });
    it('should emit a path change when a path is added', function (done) {
      (0, _testing.inject)([_polygonManager.PolygonManager], function (polygonManager) {
        var expectations = [1, 2];
        var expectationIndex = 0;
        expect.assertions(expectations.length);
        polygonManager.createPathEventObservable(newPolygon).then(function (paths$) {
          paths$.subscribe(function (polygonPathEvent) {
            expect(polygonPathEvent).toEqual({
              newArr: [[{
                lat: 15,
                lng: 15
              }]].concat(Array(expectationIndex + 1).fill([])),
              eventName: 'insert_at',
              index: expectations[expectationIndex++]
            });

            if (expectationIndex === expectations.length) {
              done();
            }
          }, fail
          /* shouldn't have errors */
          , fail
          /* shouldn't finish */
          );
          paths.push(new _mvcarrayUtils.MvcArrayMock());
          paths.push(new _mvcarrayUtils.MvcArrayMock());
        });
      })();
    });
    it('should emit a path change when a path is removed', function (done) {
      (0, _testing.inject)([_polygonManager.PolygonManager], function (polygonManager) {
        var expectations = [{
          index: 2,
          previous: [],
          newArr: [[{
            lat: 15,
            lng: 15
          }], []]
        }, {
          index: 0,
          previous: [initLatLng],
          newArr: [[]]
        }];
        var expectationIndex = 0;
        expect.assertions(expectations.length); // prepare the array

        paths.push(new _mvcarrayUtils.MvcArrayMock());
        paths.push(new _mvcarrayUtils.MvcArrayMock());
        polygonManager.createPathEventObservable(newPolygon).then(function (paths$) {
          paths$.subscribe(function (polygonPathEvent) {
            expect(polygonPathEvent).toEqual(__assign({
              eventName: 'remove_at'
            }, expectations[expectationIndex++]));

            if (expectationIndex === expectations.length) {
              done();
            }
          }, fail
          /* shouldn't have errors */
          , fail
          /* shouldn't finish */
          );
          paths.pop();
          paths.removeAt(0);
        });
      })();
    });
    it('should emit a path change when a path is set', function (done) {
      (0, _testing.inject)([_polygonManager.PolygonManager], function (polygonManager) {
        var expectations = [{
          index: 0,
          previous: [initLatLng],
          newArr: [Array(2).fill({
            lat: 15,
            lng: 15
          }), []]
        }, {
          index: 1,
          previous: [],
          newArr: [Array(2).fill({
            lat: 15,
            lng: 15
          }), [{
            lat: 15,
            lng: 15
          }]]
        }];
        var expectationIndex = 0;
        expect.assertions(expectations.length); // prepare the array

        paths.push(new _mvcarrayUtils.MvcArrayMock());
        polygonManager.createPathEventObservable(newPolygon).then(function (paths$) {
          paths$.subscribe(function (polygonPathEvent) {
            expect(polygonPathEvent).toEqual(__assign({
              eventName: 'set_at'
            }, expectations[expectationIndex++]));

            if (expectationIndex === expectations.length) {
              done();
            }
          }, fail
          /* shouldn't have errors */
          , fail
          /* shouldn't finish */
          );
          var firstMvcArray = new _mvcarrayUtils.MvcArrayMock();
          firstMvcArray.push(initLatLng);
          firstMvcArray.push(initLatLng);
          paths.setAt(0, firstMvcArray);
          var secondMvcArray = new _mvcarrayUtils.MvcArrayMock();
          secondMvcArray.push(initLatLng);
          paths.setAt(1, secondMvcArray);
        });
      })();
    });
    it('should emit a path change when a point is added to a path', function (done) {
      (0, _testing.inject)([_polygonManager.PolygonManager], function (polygonManager) {
        var expectations = [{
          pathIndex: 0,
          index: 1,
          newArr: [Array(2).fill({
            lat: 15,
            lng: 15
          })]
        }, {
          pathIndex: 0,
          index: 2,
          newArr: [Array(3).fill({
            lat: 15,
            lng: 15
          })]
        }];
        var expectationIndex = 0;
        expect.assertions(expectations.length);
        polygonManager.createPathEventObservable(newPolygon).then(function (paths$) {
          paths$.subscribe(function (polygonPathEvent) {
            expect(polygonPathEvent).toEqual(__assign({
              eventName: 'insert_at'
            }, expectations[expectationIndex++]));

            if (expectationIndex === expectations.length) {
              done();
            }
          }, fail
          /* shouldn't have errors */
          , fail
          /* shouldn't finish */
          );
          paths.getAt(0).push(initLatLng);
          paths.getAt(0).push(initLatLng);
        });
      })();
    });
    it('should emit a path change when a point is removed from a path', function (done) {
      (0, _testing.inject)([_polygonManager.PolygonManager], function (polygonManager) {
        var expectations = [{
          pathIndex: 0,
          index: 1,
          previous: initLatLng,
          newArr: [[{
            lat: 15,
            lng: 15
          }]]
        }, {
          pathIndex: 0,
          index: 0,
          previous: initLatLng,
          newArr: [[]]
        }];
        var expectationIndex = 0;
        expect.assertions(expectations.length); // prepare the array

        paths.getAt(0).push(initLatLng);
        polygonManager.createPathEventObservable(newPolygon).then(function (paths$) {
          paths$.subscribe(function (polygonPathEvent) {
            expect(polygonPathEvent).toEqual(__assign({
              eventName: 'remove_at'
            }, expectations[expectationIndex++]));

            if (expectationIndex === expectations.length) {
              done();
            }
          }, fail
          /* shouldn't have errors */
          , fail
          /* shouldn't finish */
          );
          paths.getAt(0).pop();
          paths.getAt(0).removeAt(0);
        });
      })();
    });
    it('should emit a path change when a point is added to an added path', function (done) {
      (0, _testing.inject)([_polygonManager.PolygonManager], function (polygonManager) {
        var expectations = [{
          index: 1,
          newArr: [[{
            lat: 15,
            lng: 15
          }], []]
        }, {
          pathIndex: 1,
          index: 0,
          newArr: [[{
            lat: 15,
            lng: 15
          }], [{
            lat: 15,
            lng: 15
          }]]
        }];
        var expectationIndex = 0;
        expect.assertions(expectations.length); // prepare the array

        polygonManager.createPathEventObservable(newPolygon).then(function (paths$) {
          paths$.subscribe(function (polygonPathEvent) {
            expect(polygonPathEvent).toEqual(__assign({
              eventName: 'insert_at'
            }, expectations[expectationIndex++]));

            if (expectationIndex === expectations.length) {
              done();
            }
          }, fail
          /* shouldn't have errors */
          , fail
          /* shouldn't finish */
          );
          paths.push(new _mvcarrayUtils.MvcArrayMock());
          paths.getAt(1).push(initLatLng);
        });
      })();
    });
    it('should not emit a path change when a point is added to a removed path', function (done) {
      (0, _testing.inject)([_polygonManager.PolygonManager], function (polygonManager) {
        var expectations = [{
          index: 0,
          newArr: [[]]
        }];
        var expectationIndex = 0;
        expect.assertions(expectations.length); // prepare the array

        polygonManager.createPathEventObservable(newPolygon).then(function (paths$) {
          paths$.subscribe(function (polygonPathEvent) {
            expect(polygonPathEvent).toEqual(__assign({
              eventName: 'removed_at'
            }, expectations[expectationIndex++]));
          }, fail
          /* shouldn't have errors */
          , fail
          /* shouldn't finish */
          );
          var removedPath = paths.pop();
          removedPath.pop();
          done();
        });
      })();
    });
  });
});