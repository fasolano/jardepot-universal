"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.AgmFitBounds = void 0;

var _core = require("@angular/core");

var _fitBounds = require("../services/fit-bounds");

var _rxjs = require("rxjs");

var _operators = require("rxjs/operators");

function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

var __decorate = void 0 && (void 0).__decorate || function (decorators, target, key, desc) {
  var c = arguments.length,
      r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
      d;
  if ((typeof Reflect === "undefined" ? "undefined" : _typeof(Reflect)) === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) {
    if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  }
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};

var __metadata = void 0 && (void 0).__metadata || function (k, v) {
  if ((typeof Reflect === "undefined" ? "undefined" : _typeof(Reflect)) === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};

var __param = void 0 && (void 0).__param || function (paramIndex, decorator) {
  return function (target, key) {
    decorator(target, key, paramIndex);
  };
};

/**
 * Adds the given directive to the auto fit bounds feature when the value is true.
 * To make it work with you custom AGM component, you also have to implement the {@link FitBoundsAccessor} abstract class.
 * @example
 * <agm-marker [agmFitBounds]="true"></agm-marker>
 */
var AgmFitBounds =
/** @class */
function () {
  function AgmFitBounds(_fitBoundsAccessor, _fitBoundsService) {
    this._fitBoundsAccessor = _fitBoundsAccessor;
    this._fitBoundsService = _fitBoundsService;
    /**
     * If the value is true, the element gets added to the bounds of the map.
     * Default: true.
     */

    this.agmFitBounds = true;
    this._destroyed$ = new _rxjs.Subject();
    this._latestFitBoundsDetails = null;
  }
  /**
   * @internal
   */


  AgmFitBounds.prototype.ngOnChanges = function (changes) {
    this._updateBounds();
  };
  /**
   * @internal
   */


  AgmFitBounds.prototype.ngOnInit = function () {
    var _this = this;

    this._fitBoundsAccessor.getFitBoundsDetails$().pipe((0, _operators.distinctUntilChanged)(function (x, y) {
      return x.latLng.lat === y.latLng.lng;
    }), (0, _operators.takeUntil)(this._destroyed$)).subscribe(function (details) {
      return _this._updateBounds(details);
    });
  };

  AgmFitBounds.prototype._updateBounds = function (newFitBoundsDetails) {
    if (newFitBoundsDetails) {
      this._latestFitBoundsDetails = newFitBoundsDetails;
    }

    if (!this._latestFitBoundsDetails) {
      return;
    }

    if (this.agmFitBounds) {
      this._fitBoundsService.addToBounds(this._latestFitBoundsDetails.latLng);
    } else {
      this._fitBoundsService.removeFromBounds(this._latestFitBoundsDetails.latLng);
    }
  };
  /**
   * @internal
   */


  AgmFitBounds.prototype.ngOnDestroy = function () {
    this._destroyed$.next();

    this._destroyed$.complete();

    if (this._latestFitBoundsDetails !== null) {
      this._fitBoundsService.removeFromBounds(this._latestFitBoundsDetails.latLng);
    }
  };

  __decorate([(0, _core.Input)(), __metadata("design:type", Boolean)], AgmFitBounds.prototype, "agmFitBounds", void 0);

  AgmFitBounds = __decorate([(0, _core.Directive)({
    selector: '[agmFitBounds]'
  }), __param(0, (0, _core.Self)()), __metadata("design:paramtypes", [_fitBounds.FitBoundsAccessor, _fitBounds.FitBoundsService])], AgmFitBounds);
  return AgmFitBounds;
}();

exports.AgmFitBounds = AgmFitBounds;